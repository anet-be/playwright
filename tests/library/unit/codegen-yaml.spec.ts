/**
 * Copyright (c) Microsoft Corporation.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import { test, expect } from '@playwright/test';
import { YamlLanguageGenerator, YAML_DUMP_OPTIONS } from '../../../packages/playwright-core/src/server/codegen/yaml';
import type * as actions from '@recorder/actions';
import type { LanguageGeneratorOptions } from '../../../packages/playwright-core/src/server/codegen/types';
import * as YAML from 'js-yaml';

// Helper to format a value as YAML would format it (for robust test assertions)
function formatYaml(obj: unknown): string {
  return YAML.dump(obj, YAML_DUMP_OPTIONS).replace(/\r\n?/g, '\n').trim();
}

// Helper to create a basic ActionInContext
function createAction(action: actions.Action): actions.ActionInContext {
  return {
    action,
    frame: {
      pageGuid: 'codegen-yaml.spec.ts',
      pageAlias: 'page',
      framePath: [],
    },
    startTime: Date.now(),
  };
}

// Helper to create minimal valid LanguageGeneratorOptions
function createOptions(overrides?: Partial<LanguageGeneratorOptions>): LanguageGeneratorOptions {
  return {
    browserName: 'chromium',
    launchOptions: {},
    contextOptions: {},
    ...overrides,
  };
}

test.describe('YamlLanguageGenerator', () => {
  let generator: YamlLanguageGenerator;

  test.beforeEach(() => {
    generator = new YamlLanguageGenerator();
  });

  test('should generate correct header', () => {
    const header = generator.generateHeader(createOptions({ contextOptions: { baseURL: 'https://example.com' } }));

    expect(header).toContain('# Generated by Genfest');
    // Header is emitted incrementally, so just check for the comment
  });

  test('should generate navigate action', () => {
    const action: actions.NavigateAction = {
      name: 'navigate',
      url: 'https://example.com/page',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: 'navigate' }));
    // URL is now relative after baseURL extraction
    expect(result).toContain(formatYaml({ url: '/page' }));
    // And baseURL is extracted
    expect(result).toContain(formatYaml({ baseURL: 'https://example.com' }));
  });

  test('should skip about:blank navigation', () => {
    const action: actions.NavigateAction = {
      name: 'navigate',
      url: 'about:blank',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toBe('');
  });

  test('should generate click action', () => {
    const action: actions.ClickAction = {
      name: 'click',
      selector: 'button',
      signals: [],
      button: 'left',
      modifiers: 0,
      clickCount: 1,
      position: undefined,
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "click" }));
  });

  test('should generate dblclick action', () => {
    const action: actions.ClickAction = {
      name: 'click',
      selector: 'button',
      signals: [],
      button: 'left',
      modifiers: 0,
      clickCount: 2,
      position: undefined,
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "dblclick" }));
  });

  test('should generate right-click action', () => {
    const action: actions.ClickAction = {
      name: 'click',
      selector: 'button',
      signals: [],
      button: 'right',
      modifiers: 0,
      clickCount: 1,
      position: undefined,
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ button: "right" }));
  });

  test('should generate fill action', () => {
    const action: actions.FillAction = {
      name: 'fill',
      selector: 'input',
      text: 'test value',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "fill" }));
    expect(result).toContain(formatYaml({ text: "test value" }));
  });

  test('should mask password fields based on CSS selector', () => {
    // Test masking based on CSS selector containing "password"
    const action: actions.FillAction = {
      name: 'fill',
      selector: 'input.password-field',
      text: 'secret123',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain('ANET_PASSWORD');
    expect(result).not.toContain('secret123');
  });

  test('should generate press action', () => {
    const action: actions.PressAction = {
      name: 'press',
      selector: 'input',
      key: 'Enter',
      modifiers: 0,
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "press" }));
    expect(result).toContain(formatYaml({ key: "Enter" }));
  });

  test('should generate check action', () => {
    const action: actions.CheckAction = {
      name: 'check',
      selector: 'input[type="checkbox"]',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "check" }));
  });

  test('should generate uncheck action', () => {
    const action: actions.UncheckAction = {
      name: 'uncheck',
      selector: 'input[type="checkbox"]',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "uncheck" }));
  });

  test('should generate select action with value', () => {
    const action: actions.SelectAction = {
      name: 'select',
      selector: 'select',
      options: ['value1'],
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "select" }));
    expect(result).toContain(formatYaml({ value: "value1" }));
  });

  test('should generate select action with multiple values', () => {
    const action: actions.SelectAction = {
      name: 'select',
      selector: 'select',
      options: ['value1', 'value2'],
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "select" }));
    expect(result).toContain(formatYaml({ value: "value1" }));
    expect(result).toContain(formatYaml({ value: "value2" }));
  });

  test('should generate assertText action', () => {
    const action: actions.AssertTextAction = {
      name: 'assertText',
      selector: 'div',
      text: 'expected text',
      substring: false,
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "assert.text" }));
    expect(result).toContain(formatYaml({ text: "expected text" }));
  });

  test('should generate assertValue action', () => {
    const action: actions.AssertValueAction = {
      name: 'assertValue',
      selector: 'input',
      value: 'expected value',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "assert.value" }));
    expect(result).toContain(formatYaml({ value: "expected value" }));
  });

  test('should generate assertChecked action', () => {
    const action: actions.AssertCheckedAction = {
      name: 'assertChecked',
      selector: 'input',
      checked: true,
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "assert.checked" }));
    expect(result).toContain('checked: true');
  });

  test('should generate assertVisible action', () => {
    const action: actions.AssertVisibleAction = {
      name: 'assertVisible',
      selector: 'div',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "assert.visible" }));
  });

  test('should generate closePage action', () => {
    const action: actions.ClosesPageAction = {
      name: 'closePage',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "closePage" }));
  });

  test('should handle frame paths', () => {
    const action: actions.ClickAction = {
      name: 'click',
      selector: 'button',
      signals: [],
      button: 'left',
      modifiers: 0,
      clickCount: 1,
      position: undefined,
    };

    const actionInContext: actions.ActionInContext = {
      action,
      frame: {
        pageGuid: 'codegen-yaml.spec.ts',
        pageAlias: 'page',
        framePath: ['iframe[name="content"]'],
      },
      startTime: Date.now(),
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(actionInContext);

    expect(result).toContain('framePath:');
  });

  test('should handle special characters in text', () => {
    const action: actions.FillAction = {
      name: 'fill',
      selector: 'input',
      text: 'text with "quotes" and \'apostrophes\'',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    expect(result).toContain(formatYaml({ action: "fill" }));
    // YAML should handle special characters correctly
    expect(result).toContain('text:');
  });

  test('should use single quotes by default', () => {
    const action: actions.NavigateAction = {
      name: 'navigate',
      url: 'https://example.com',
      signals: [],
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    // YAML.dump uses single quotes by default
    expect(result).toContain(formatYaml({ action: "navigate" }));
    // URL is now relative (just '/') after baseURL extraction
    expect(result).toContain(formatYaml({ url: "/" }));
    // And baseURL is extracted as origin
    expect(result).toContain(formatYaml({ baseURL: "https://example.com" }));
  });

  test('should generate selector with hasText filter', () => {
    // Corresponds to user writing: locator('div').filter({ hasText: 'Hello' })
    // Internal selector: div >> internal:has-text="Hello"
    const action: actions.ClickAction = {
      name: 'click',
      selector: 'div >> internal:has-text="Hello"',
      signals: [],
      button: 'left',
      modifiers: 0,
      clickCount: 1,
      position: undefined,
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    // Expected YAML structure:
    // selector:
    //   element:
    //     css: 'div'
    //   filters:
    //     hasText: 'Hello'

    expect(result).toContain(formatYaml({ action: "click" }));
    expect(result).toContain(formatYaml({ css: "div" }));
    expect(result).toContain("filters:");
    expect(result).toContain(formatYaml({ hasText: "Hello" }));
  });

  test('should generate selector with nested has filter', () => {
    // Corresponds to user writing: locator('article').filter({ has: locator('button') })
    // Internal selector: article >> internal:has="button"
    const action: actions.ClickAction = {
      name: 'click',
      selector: 'article >> internal:has="button"',
      signals: [],
      button: 'left',
      modifiers: 0,
      clickCount: 1,
      position: undefined,
    };

    generator.generateHeader(createOptions());
    const result = generator.generateAction(createAction(action));

    // Expected YAML structure:
    // selector:
    //   element:
    //     css: 'article'
    //   filters:
    //     has:
    //       element:
    //         css: 'button'

    expect(result).toContain(formatYaml({ css: "article" }));
    expect(result).toContain("filters:");
    expect(result).toContain("has:");
    // The nested element
    expect(result).toContain(formatYaml({ css: "button" }));
  });
});
